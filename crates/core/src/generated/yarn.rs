// This file is @generated by prost-build.
/// A complete Yarn program.
use crate::prelude::*;
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "bevy", derive(Reflect))]
#[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
#[cfg_attr(all(feature = "bevy", feature = "serde"), reflect(Serialize, Deserialize))]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Program {
    /// The name of the program.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The collection of nodes in this program.
    #[prost(btree_map = "string, message", tag = "2")]
    pub nodes: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        Node,
    >,
    /// The collection of initial values for variables; if a PUSH_VARIABLE
    /// instruction is run, and the value is not found in the storage, this
    /// value will be used
    #[prost(btree_map = "string, message", tag = "3")]
    pub initial_values: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        Operand,
    >,
}
/// A collection of instructions
use crate::prelude::*;
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "bevy", derive(Reflect))]
#[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
#[cfg_attr(all(feature = "bevy", feature = "serde"), reflect(Serialize, Deserialize))]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    /// The name of this node.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The list of instructions in this node.
    #[prost(message, repeated, tag = "7")]
    pub instructions: ::prost::alloc::vec::Vec<Instruction>,
    /// The headers present on this node.
    #[prost(message, repeated, tag = "6")]
    pub headers: ::prost::alloc::vec::Vec<Header>,
}
use crate::prelude::*;
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "bevy", derive(Reflect))]
#[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
#[cfg_attr(all(feature = "bevy", feature = "serde"), reflect(Serialize, Deserialize))]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    /// The name of the header.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// The value of the header.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
use crate::prelude::*;
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "bevy", derive(Reflect))]
#[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
#[cfg_attr(all(feature = "bevy", feature = "serde"), reflect(Serialize, Deserialize))]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instruction {
    #[prost(
        oneof = "instruction::InstructionType",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23"
    )]
    pub instruction_type: ::core::option::Option<instruction::InstructionType>,
}
/// Nested message and enum types in `Instruction`.
pub mod instruction {
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PeekAndJumpInstruction {}
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PeekAndRunNodeInstruction {}
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ShowOptionsInstruction {}
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PushStringInstruction {
        /// The value to push.
        #[prost(string, tag = "1")]
        pub value: ::prost::alloc::string::String,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PushFloatInstruction {
        /// The value to push.
        #[prost(float, tag = "1")]
        pub value: f32,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PushBoolInstruction {
        /// The value to push.
        #[prost(bool, tag = "1")]
        pub value: bool,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct JumpToInstruction {
        /// The instruction number in the current node to jump to.
        #[prost(int32, tag = "1")]
        pub destination: i32,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RunLineInstruction {
        /// The ID of the localised content that should be shown for this line.
        ///         string lineID = 1;
        #[prost(uint32, tag = "100")]
        pub line_id: u32,
        /// The number of substitutions present in this line that must be popped
        /// off the stack.
        #[prost(int32, tag = "2")]
        pub substitution_count: i32,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RunCommandInstruction {
        /// The text of the command to send to the client.
        #[prost(string, tag = "1")]
        pub command_text: ::prost::alloc::string::String,
        /// The number of substitutions present in this command that must be popped
        /// off the stack.
        #[prost(int32, tag = "2")]
        pub substitution_count: i32,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AddOptionInstruction {
        /// The ID of the content that should be shown for this option.
        ///         string lineID = 1;
        #[prost(uint32, tag = "100")]
        pub tag_id: u32,
        /// The instruction number in the current node to jump to if this option
        /// is selected.
        #[prost(int32, tag = "2")]
        pub destination: i32,
        /// The number of substitutions present in this option that must be popped
        /// off the stack.
        #[prost(int32, tag = "3")]
        pub substitution_count: i32,
        /// A value indicating whether this instruction has a line condition on
        /// it, whose evaluated value must be popped off the stack.
        #[prost(bool, tag = "4")]
        pub has_condition: bool,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct JumpIfFalseInstruction {
        /// The instruction number in the current node to jump to.
        #[prost(int32, tag = "1")]
        pub destination: i32,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PopInstruction {}
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallFunctionInstruction {
        /// The name of the function to call.
        #[prost(string, tag = "1")]
        pub function_name: ::prost::alloc::string::String,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PushVariableInstruction {
        /// The name of the variable whose value should be pushed onto the stack.
        #[prost(string, tag = "1")]
        pub variable_name: ::prost::alloc::string::String,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StoreVariableInstruction {
        /// The name of the variable whose value should be updated with the value
        /// currently on top of the stack.
        #[prost(string, tag = "1")]
        pub variable_name: ::prost::alloc::string::String,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StopInstruction {}
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RunNodeInstruction {
        /// The name of the node to begin running.
        #[prost(string, tag = "1")]
        pub node_name: ::prost::alloc::string::String,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DetourToNodeInstruction {
        #[prost(string, tag = "1")]
        pub node_name: ::prost::alloc::string::String,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PeekAndDetourToNode {}
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReturnInstruction {}
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddSaliencyCandidateInstruction {
        /// The unique ID for this piece of content, such as a line ID.
        #[prost(string, tag = "1")]
        pub content_id: ::prost::alloc::string::String,
        /// The complexity score of the candidate.
        #[prost(int32, tag = "2")]
        pub complexity_score: i32,
        /// The instruction number in the current node to jump to if this
        /// candidate is selected.
        #[prost(int32, tag = "3")]
        pub destination: i32,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddSaliencyCandidateFromNodeInstruction {
        /// The name of the node to get saliency information from.
        #[prost(string, tag = "1")]
        pub node_name: ::prost::alloc::string::String,
        /// The instruction number in the current node to jump to if this
        /// candidate is selected.
        #[prost(int32, tag = "2")]
        pub destination: i32,
    }
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SelectSaliencyCandidateInstruction {}
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum InstructionType {
        /// Jumps to a specified position in the current node.
        #[prost(message, tag = "1")]
        JumpTo(JumpToInstruction),
        /// Peeks a number on the stack, and jumps to that position in the
        /// current node.
        #[prost(message, tag = "2")]
        PeekAndJump(PeekAndJumpInstruction),
        /// Runs a line of dialogue.
        #[prost(message, tag = "3")]
        RunLine(RunLineInstruction),
        /// Runs a command.
        #[prost(message, tag = "4")]
        RunCommand(RunCommandInstruction),
        /// Adds an option to the 'pending options' list.
        #[prost(message, tag = "5")]
        AddOption(AddOptionInstruction),
        /// Shows all options in the 'pending options' list, then clears the list.
        #[prost(message, tag = "6")]
        ShowOptions(ShowOptionsInstruction),
        /// Pushes a string onto the stack.
        #[prost(message, tag = "7")]
        PushString(PushStringInstruction),
        /// Pushes a floating point number onto the stack.
        #[prost(message, tag = "8")]
        PushFloat(PushFloatInstruction),
        /// Pushes a boolean onto the stack.
        #[prost(message, tag = "9")]
        PushBool(PushBoolInstruction),
        /// Peeks a boolean on the stack, and if it's false, jumps to the
        /// indicated position in the current node.
        #[prost(message, tag = "10")]
        JumpIfFalse(JumpIfFalseInstruction),
        /// Pops a value of any kind off the stack.
        #[prost(message, tag = "11")]
        Pop(PopInstruction),
        /// Calls a named function.
        #[prost(message, tag = "12")]
        CallFunc(CallFunctionInstruction),
        /// Pushes the value of the named variable onto the stack.
        #[prost(message, tag = "13")]
        PushVariable(PushVariableInstruction),
        /// Peeks a value of any kind on the stack, and stores it in the
        /// indicated variable.
        #[prost(message, tag = "14")]
        StoreVariable(StoreVariableInstruction),
        /// Halts execution.
        #[prost(message, tag = "15")]
        Stop(StopInstruction),
        /// Jumps to the start of a named node.
        #[prost(message, tag = "16")]
        RunNode(RunNodeInstruction),
        /// Peeks a string on the stack, and jumps to the start of that node.
        #[prost(message, tag = "17")]
        PeekAndRunNode(PeekAndRunNodeInstruction),
        #[prost(message, tag = "18")]
        DetourToNode(DetourToNodeInstruction),
        #[prost(message, tag = "19")]
        PeekAndDetourToNode(PeekAndDetourToNode),
        #[prost(message, tag = "20")]
        Return(ReturnInstruction),
        /// Pops a boolean from the stack, and adds a saliency candidate to the
        /// current list.
        #[prost(message, tag = "21")]
        AddSaliencyCandidate(AddSaliencyCandidateInstruction),
        /// Add a saliency candidate to the current list, given a node name.
        #[prost(message, tag = "22")]
        AddSaliencyCandidateFromNode(AddSaliencyCandidateFromNodeInstruction),
        /// Attempt to select a single saliency candidate from the current list:
        /// - if one is selected, pushes the destination of that candidate and
        ///    the value 'true'
        /// - if none is selected, pushes the value 'false'
        ///
        /// In all circumstances, clears the saliency candidate list before
        /// returning.
        #[prost(message, tag = "23")]
        SelectSaliencyCandidate(SelectSaliencyCandidateInstruction),
    }
}
/// A single Yarn instruction.
use crate::prelude::*;
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "bevy", derive(Reflect))]
#[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
#[cfg_attr(all(feature = "bevy", feature = "serde"), reflect(Serialize, Deserialize))]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstructionV1 {
    /// The operation that this instruction will perform.
    #[prost(enumeration = "instruction_v1::OpCode", tag = "1")]
    pub opcode: i32,
    /// The list of operands, if any, that this instruction uses.
    #[prost(message, repeated, tag = "2")]
    pub operands: ::prost::alloc::vec::Vec<Operand>,
}
/// Nested message and enum types in `InstructionV1`.
pub mod instruction_v1 {
    /// The type of instruction that this is.
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OpCode {
        /// Jumps to a named position in the node.
        /// opA = string: label name
        JumpTo = 0,
        /// Peeks a string from stack, and jumps to that named position in
        /// the node.
        /// No operands.
        Jump = 1,
        /// Delivers a string ID to the client.
        /// opA = string: string ID
        RunLine = 2,
        /// Delivers a command to the client.
        /// opA = string: command text
        RunCommand = 3,
        /// Adds an entry to the option list (see ShowOptions).
        /// - opA = string: string ID for option to add
        /// - opB = string: destination to go to if this option is selected
        /// - opC = number: number of expressions on the stack to insert
        ///    into the line
        /// - opD = bool: whether the option has a condition on it (in which
        ///    case a value should be popped off the stack and used to signal
        ///    the game that the option should be not available)
        AddOption = 4,
        /// Presents the current list of options to the client, then clears
        /// the list. The most recently selected option will be on the top
        /// of the stack when execution resumes.
        /// No operands.
        ShowOptions = 5,
        /// Pushes a string onto the stack.
        /// opA = string: the string to push to the stack.
        PushString = 6,
        /// Pushes a floating point number onto the stack.
        /// opA = float: number to push to stack
        PushFloat = 7,
        /// Pushes a boolean onto the stack.
        /// opA = bool: the bool to push to stack
        PushBool = 8,
        /// Pushes a null value onto the stack.
        /// No operands.
        PushNull = 9,
        /// Jumps to the named position in the the node, if the top of the
        /// stack is not null, zero or false.
        /// opA = string: label name
        JumpIfFalse = 10,
        /// Discards top of stack.
        /// No operands.
        Pop = 11,
        /// Calls a function in the client. Pops as many arguments as the
        /// client indicates the function receives, and the result (if any)
        /// is pushed to the stack.		
        /// opA = string: name of the function
        CallFunc = 12,
        /// Pushes the contents of a variable onto the stack.
        /// opA = name of variable
        PushVariable = 13,
        /// Stores the contents of the top of the stack in the named
        /// variable.
        /// opA = name of variable
        StoreVariable = 14,
        /// Stops execution of the program.
        /// No operands.
        Stop = 15,
        /// Pops a string off the top of the stack, and runs the node with
        /// that name.
        /// No operands.
        RunNode = 16,
    }
    impl OpCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::JumpTo => "JUMP_TO",
                Self::Jump => "JUMP",
                Self::RunLine => "RUN_LINE",
                Self::RunCommand => "RUN_COMMAND",
                Self::AddOption => "ADD_OPTION",
                Self::ShowOptions => "SHOW_OPTIONS",
                Self::PushString => "PUSH_STRING",
                Self::PushFloat => "PUSH_FLOAT",
                Self::PushBool => "PUSH_BOOL",
                Self::PushNull => "PUSH_NULL",
                Self::JumpIfFalse => "JUMP_IF_FALSE",
                Self::Pop => "POP",
                Self::CallFunc => "CALL_FUNC",
                Self::PushVariable => "PUSH_VARIABLE",
                Self::StoreVariable => "STORE_VARIABLE",
                Self::Stop => "STOP",
                Self::RunNode => "RUN_NODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JUMP_TO" => Some(Self::JumpTo),
                "JUMP" => Some(Self::Jump),
                "RUN_LINE" => Some(Self::RunLine),
                "RUN_COMMAND" => Some(Self::RunCommand),
                "ADD_OPTION" => Some(Self::AddOption),
                "SHOW_OPTIONS" => Some(Self::ShowOptions),
                "PUSH_STRING" => Some(Self::PushString),
                "PUSH_FLOAT" => Some(Self::PushFloat),
                "PUSH_BOOL" => Some(Self::PushBool),
                "PUSH_NULL" => Some(Self::PushNull),
                "JUMP_IF_FALSE" => Some(Self::JumpIfFalse),
                "POP" => Some(Self::Pop),
                "CALL_FUNC" => Some(Self::CallFunc),
                "PUSH_VARIABLE" => Some(Self::PushVariable),
                "STORE_VARIABLE" => Some(Self::StoreVariable),
                "STOP" => Some(Self::Stop),
                "RUN_NODE" => Some(Self::RunNode),
                _ => None,
            }
        }
    }
}
/// A value used by an Instruction.
use crate::prelude::*;
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "bevy", derive(Reflect))]
#[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
#[cfg_attr(all(feature = "bevy", feature = "serde"), reflect(Serialize, Deserialize))]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operand {
    /// The type of operand this is.
    #[prost(oneof = "operand::Value", tags = "1, 2, 3")]
    pub value: ::core::option::Option<operand::Value>,
}
/// Nested message and enum types in `Operand`.
pub mod operand {
    /// The type of operand this is.
    use crate::prelude::*;
    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "bevy", derive(Reflect))]
    #[cfg_attr(feature = "bevy", reflect(Debug, PartialEq))]
    #[cfg_attr(
        all(feature = "bevy", feature = "serde"),
        reflect(Serialize, Deserialize)
    )]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// A string.
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
        /// A boolean (true or false).
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        /// A floating point number.
        #[prost(float, tag = "3")]
        FloatValue(f32),
    }
}
